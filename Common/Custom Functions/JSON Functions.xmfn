<?xml version="1.0" encoding="UTF-8"?><FMClipboard><Version><![CDATA[41011080]]></Version><Comment><![CDATA[v18+ only]]></Comment><SourceWindowName></SourceWindowName><Class>XMFN</Class><ClipVersion>1</ClipVersion><ClipTimeStamp>3637300875</ClipTimeStamp><ClipAuthor><![CDATA[gsbcs]]></ClipAuthor><clipboardAsText><![CDATA[JSON.array.appendKey( array )
JSON.array.count( array )
JSON.array.toList( array )
JSON.array.fromList( lst;type )
JSON.array.push( arr;val;type )
JSON.defaultTo( jsonResult;default )
JSON.record.getData( Definition )
JSON.record.getFields( context )
JSON.setVariables( json )
JSON.getContiguousTimeBlocks( JSON.sortedAndCategorizedStartsAndEnds )]]></clipboardAsText><Clipboard><fmxmlsnippet type="FMObjectList"><CustomFunction id="14" functionArity="1" visible="True" parameters="array" name="JSON.array.appendKey"><Calculation>Let ([b=""
;	indices = JSONListKeys ( array ; "" )
;	next = Case ( Left ( indices ; 1 ) = "?" ; 0 ; GetAsNumber ( GetValue ( indices ; ValueCount ( indices ) ) ) + 1 )
];
next
)</Calculation></CustomFunction><CustomFunction id="58" functionArity="1" visible="True" parameters="array" name="JSON.array.count"><Calculation>Case ( IsEmpty ( array ) ; 0 ; Let ([b=""

;	keys	= JSONListKeys ( array ; "" )
;	cnt	= Case ( Left ( keys ; 1 ) = "?" ; 0 ; ValueCount ( keys ) )
	
];
cnt
))</Calculation></CustomFunction><CustomFunction id="61" functionArity="1" visible="True" parameters="array" name="JSON.array.toList"><Calculation>Case ( array = "[]" or Left ( array ; 1 ) = "?" ; "" ; JSONListValues ( array ; "" ) )</Calculation></CustomFunction><CustomFunction id="17" functionArity="2" visible="True" parameters="lst;type" name="JSON.array.fromList"><Calculation>Let ([b=""

;	$_array	= "[]"

;	template	= ";	$_array = JSON.array.push ( $_array ; " &amp; Case ( type = JSONNumber ; "{{value}}" ; Quote ( "{{value}}" ) ) &amp; " ; " &amp; type &amp; " )"
;	values = lst
;	pushes	= List.fillTemplate ( template ; lst )
;	str	= List (""
			; "Let ([b=\"\""
			; ";	$_array = \"[]\""
			;	pushes
			; "];"
			; "	$_array"
			; ")"
			)

;	res	= Evaluate ( str )
;	output	= $_array
;	$_array	= ""

];
output
)</Calculation></CustomFunction><CustomFunction id="16" functionArity="3" visible="True" parameters="arr;val;type" name="JSON.array.push"><Calculation>Let ([b=""
/*
;	arr	= "[]"
;	val	= "test"
;	type 	= JSONString
*/

;	keys	= JSONListKeys ( arr ; "" )
;	len	= ValueCount ( keys )

;	thisKey	= GetValue ( keys ; len )
;	nextKey	= Case ( IsEmpty ( thisKey ) ; 0 ; thisKey + 1 )

;	return	= JSONSetElement ( arr ; nextKey ; val ; type )

];
	return
)</Calculation></CustomFunction><CustomFunction id="20" functionArity="2" visible="True" parameters="jsonResult;default" name="JSON.defaultTo"><Calculation>Case ( Left ( jsonResult ; 1 ) = "?" ; default ; jsonResult )</Calculation></CustomFunction><CustomFunction id="12" functionArity="1" visible="True" parameters="Definition" name="JSON.record.getData"><Calculation>/*
 * @author Steve Allen &lt;steven.allen@rcconsulting.com&gt;
 *    @gitHub steveAllen0112
 *
 * @purpose To contextually and consistently produce record data in JSON format
 *     Uses the Schema Definition provided to it (See `JSON.record.getFields()` as a way to produce that.)
 *     This prevents having to hard-code a CF for each table, and allows flexibility to be as consistent or not as needed at runtime.
 * 
 * @param *required Definition (object)
 *    @property *required _table (string) The name of the Table Occurrence to grab the data from.  Must be reachable in the context.
 *        Only required at the first level of the call, but must be present there or the CF will not work,
 *           because it's used to fully qualify the field definitions passed in the rest of the Schema Definition
 *    @properties *required {Schema-Definition} See the @return value on the `JSON.record.getFields()` function.
 *
 * @returns {record-data} (object)
 *     Exact structure will vary according to the Definition provided, but will match that definition's structure.
 */

Let ([b=""
;	debug = False

;	properties		= JSON.defaultTo ( JSONListKeys ( Definition ; "" ) ; "" )

;	hasTableDefinition	= ValueCount ( FilterValues ( properties ; "_table" ) ) &gt;= 1
;	isFieldDefinition		= ValueCount ( FilterValues ( properties ; List ( "field" ; "type" ; "reps" ) ) ) &gt;= 3 /* these all have to be there for it to be considered a Field Definition. */

;	Definition		= Case ( hasTableDefinition
					;	Let ([b=""
						;	$_log = ""
						;	$_output = ""
						;	$_iterator = ""
						;	$_context = JSONSetElement ( "{}"
								;[ "table" ; JSON.defaultTo ( JSONGetElement ( Definition ; "_table" ) ; "" ) ; JSONString ]
								)
						];
							JSONDeleteElement ( Definition ; "_table" )
						)
					; Definition
					)

;	$_iterator		= Case ( IsEmpty ( $_iterator )
					;	JSONSetElement ( "{}"
							;[ "iteration" ; 1 ; JSONNumber ]
							;[ "stopAt" ; Case (0;0
								;	isFieldDefinition
								;		JSON.defaultTo ( JSONGetElement ( Definition ; "reps" ) ; "" )
								;	ValueCount ( properties ) - hasTableDefinition
								) ; JSONNumber ]
							)
					; $_iterator
					)

;	Iterator			= $_iterator


;	$_log			= Case ( debug ; List ( $_log ; "---------" ; JSONSetElement ( "{}"
					;[ "properties" ; properties ; JSONString ]
					;[ "isFieldDefinition" ; isFieldDefinition ; JSONBoolean ]
					;[ "Iterator" ; Iterator ; JSONObject ]
					;[ "output" ; $_output ; JSONObject ]
					)))


;	iteration			= JSON.defaultTo ( JSONGetElement ( Iterator ; "iteration" ) ; "" )

;	dig			= Case (0;0
				;	isFieldDefinition
				;		Let ([b=""
						;	table			= JSON.defaultTo ( JSONGetElement ( $_context ; "table" ) ; "" )
						;	field.name		= JSON.defaultTo ( JSONGetElement ( Definition ; "field" ); "" )
						;	field.type		= JSON.defaultTo ( JSONGetElement ( Definition ; "type" ); "" )
						;	field.reps		= JSON.defaultTo ( JSONGetElement ( Definition ; "reps" ); "" )
						;	field.rep			= iteration
						;	field.name.fullyQualified	= Substitute ( "{{table}}::{{field}}[{{rep}}]"
											;[ "{{table}}" ; Table ]
											;[ "{{field}}" ; field.name ]
											;[ "{{rep}}" ; field.rep ]
											)
						;	field.value		= Evaluate ( field.name.fullyQualified )

						;	field.jsonKey		= field.name &amp; Case ( field.reps &gt; 1 ; "." &amp; field.rep )

						;	$_log			= Case ( debug ; List ( $_log ; "      ----- " ; JSONSetElement ( "{}"
											;[ "field.name" ; field.name ; JSONString ]
											;[ "field.type" ; field.type ; JSONNumber ]
											;[ "field.reps" ; field.reps ; JSONNumber ]
											;[ "field.rep" ; field.rep ; JSONNumber ]
											;[ "field.fullyQualifiedName" ; field.name.fullyQualified ; JSONString ]
											;[ "field.jsonKey" ; field.jsonKey ; JSONString ]
											;[ "field.value" ; field.value ; JSONString ]
											)))

						;	$_output			= JSONSetElement ( $_output ; field.jsonKey ; field.value ; field.type )
						];"")
				;	Let ([b=""
					;	thisProp		= GetValue ( properties ; iteration )
					;	thisPropVal	= JSONGetElement ( Definition ; thisProp )

					;	$_log		= Case ( debug ; List ( $_log ; "  -- " ; JSONSetElement ( "{}"
									;[ "thisProp.name" ; thisProp ; JSONString ]
									;[ "thisProp.value" ; thisPropVal ; Case ( Left ( thisPropVal ; 1 ) = "{" ; JSONObject ; JSONString ) ]
									)))

					;	$_iterator	= ""
					;	dig		= JSON.record.getData ( thisPropVal )
					;	$_iterator	= Iterator
					]; "" )
				)

	/* Now iterate as necessary */
;	stopAt			= JSON.defaultTo ( JSONGetElement ( Iterator ; "stopAt" ) ; 0 )
;	iterate			= Case ( iteration &lt;  stopAt
					; Let ( $_iterator = JSONSetElement ( $_iterator ; "iteration" ; iteration + 1 ; JSONNumber )
						; JSON.record.getData ( Definition )
						)
					)
];
Case ( debug ; $_log ; $_output )
)</Calculation></CustomFunction><CustomFunction id="11" functionArity="1" visible="True" parameters="context" name="JSON.record.getFields"><Calculation>/*
 * @author Steve Allen &lt;steven.allen@rcconsulting.com&gt;
 * @purpose To provide a flexible method of consistently defining a data structure for a table such that other functions (e.g. `JSON.record.getData()`) can follow it and read data out of the record.
 *
 * @param context (object)
 *   @property *required _table (string) The name of the TO that will be used to get the field data.
 *   @property *optional config (object)
 *      @property *optional include (array) If this array is present, it will limit the fields included to only those specified therein.
 *        @member *optional field (string) The name (field only, not the fully qualified name) of the field you wish to include.
 *      @property *optional exclue (array) If this array is present, it will actively prevent inclusion of those fields specified therein.
 *        @member *optional field (string) The name (field only, not the fully qualified name) of the field you wish to exclude.
 *
 * @returns (object)
 *    @property {hierarchy-parent | Field-Definition} (obj)
 *        hiearchy-parent If field names have dots in them, they will be treated as a JSON path.  e.g. name.first.  So the hierarchy parent would have the children within that hiearchy as properties under it
 *        Field-Definition At the lowest level of the naming hierarchy, the actual definition
 *          @property field (str) The full, unqualified name of the field.
 *          @property type (number) The numeric representation of the JSON type as specified by FileMaker's built in constants.
 *             (JSONNumber | JSONString )
 *          @property reps (number) The number of repetitions defined for the field.
 */

Let ([b=""

;	context.table	= JSON.defaultTo ( JSONGetElement ( context ; "table" ) ; "" )
;	config.include	= JSON.defaultTo ( JSONGetElement ( context ; "config.include" ) ; "" )
;	config.exclude	= JSON.defaultTo ( JSONGetElement ( context ; "config.exclude" ) ; "" )

;	$record = "{}"

;	config.include	= Case ( not IsEmpty ( config.include ) ; Substitute ( config.include
					;[ "\"" ; "'" ]
					;[ "[" ; "(" ]
					;[ "]" ; ")" ]
					)
				)
;	config.exclude	= Case ( not IsEmpty ( config.exclude ) ; Substitute ( config.exclude
					;[ "\"" ; "'" ]
					;[ "[" ; "(" ]
					;[ "]" ; ")" ]
					)
				)

;	flds = Substitute ( List ( ""
		; "'	$record	= JSONSetElement ( $record'"
		; "'			;[ \"' + FieldName + '.field\" ; \"' + FieldName + '\" ; JSONString ]'"
		; "'			;[ \"' + FieldName + '.type\" ; ' +
						CASE
							WHEN FieldType LIKE 'decimal%' THEN 'JSONNumber'
							ELSE 'JSONString'
						END
				+ ' ; JSONNumber ]'"
		; "'			;[ \"' + FieldName + '.reps\" ; ' + CAST ( FieldReps AS varchar ) + ' ; JSONNumber ]'"
		; "'			)'"
		)
		;[ "¶" ; ",¶" ]
		)

;	sqlStr = "
SELECT
	" &amp; flds &amp; "

FROM FileMaker_Fields

WHERE
		TableName=?
	AND	FieldClass='Normal'
"
&amp; Case ( not IsEmpty ( config.include ) ; " AND FieldName IN " &amp; config.include )
&amp; Case ( not IsEmpty ( config.exclude ) ; " AND FieldName NOT IN " &amp; config.exclude ) 

;	sqlRes = ExecuteSQL ( sqlStr ; "¶" ; ";" ; context.table )
;	errChk = Case ( sqlRes = "?" ; "" ; "Let ([ b=\"\";" &amp; sqlRes &amp; "];$record)" )

;	json = Case ( IsValidExpression ( errChk ) ; Evaluate ( errChk ) ; "" )

];
json
)</Calculation></CustomFunction><CustomFunction id="23" functionArity="1" visible="True" parameters="json" name="JSON.setVariables"><Calculation>Case ( not IsValidExpression ( While (i=0;0;i=0;0) ) ; "?" ;

While ([b=""
/* For Testing
;	json = JSONSetElement ( "{}"
		;[ "test[0].hello" ; "world" ; JSONString ]
		;[ "test[0].ping" ; "pong" ; JSONString ]
		;[ "test[1].number" ; 1 ; JSONNumber ]
		;[ "test[1].date" ; GetAsNumber ( Get ( CurrentDate ) ) ; JSONNumber ]
		)
*/
;	path = "[]"
;	variables = ""
;	currentJson = json
]; ValueCount ( JSONListKeys ( json ; "" ) )
;[b=""
;	jsonPath = Substitute ( JSONListValues ( path ; "" ) ; "¶" ; "." )

;	currentJson = JSONGetElement ( json ; jsonPath )

;	currentJson.isValue	= Left ( JSONFormatElements ( currentJson ) ; 1 ) = "?"
;	currentJson.isArray	= (not currentJson.isValue) and Left ( currentJson ; 1 ) = "["
;	currentJson.isObject	= (not currentJson.isValue) and Left ( currentJson ; 1 ) = "{"
;	currentJson.isDone	= (currentJson.isArray or currentJson.isObject) and Length ( currentJson ) = 2

;	variables = Case (0;0
			;	currentJson.isValue
			;		Let ([b=""
					;	variable = "$" &amp; Substitute ( jsonPath ; [ "[" ; "" ] ; [ "]" ; "" ] )
					;	evalStr	= "Let(" &amp; variable &amp; "=" &amp; Quote ( currentJson ) &amp; ";\"\")"
					;	set = Evaluate ( evalStr )
					];
						List ( variables ; variable )
					)
			;	variables
			)

;	path	= Case (0;0
			;	currentJson.isValue or currentJson.isDone
			;		Let ([b=""
					;	pathkeys = JSONListKeys ( path ; "" )
					;	latestPathKey = GetValue ( pathkeys ; ValueCount ( pathkeys ) )
					];
						JSONDeleteElement ( path ; latestPathKey )
					)
			;	currentJson.isObject or currentJson.isArray
			;		Let ([b=""
					;	pathkeys = JSONListKeys ( path ; "" )
					;	latestPathKey = GetValue ( pathkeys ; ValueCount ( pathkeys ) )
					;	nextKey = GetValue ( JSONListKeys ( currentJson ; "" ) ; 1 )
					;	nextKey = Case ( currentJson.isArray ; "[" &amp; nextKey &amp; "]" ; nextKey )
					];
						JSONSetElement ( path ; "[" &amp; latestPathKey + 1 &amp; "]" ; nextKey ; JSONString )
					)
			;	path
			)
;	json	= Case (0;0
			;	currentJson.isValue or currentJson.isDone
			;		JSONDeleteElement ( json ; jsonPath )
			;	json
			)
];
variables
) )</Calculation></CustomFunction><CustomFunction id="2" functionArity="1" visible="True" parameters="JSON.sortedAndCategorizedStartsAndEnds" name="JSON.getContiguousTimeBlocks"><Calculation>/**
 * by Steve Allen &lt;steven.allen@rcconsulting.com&gt;
 * gh@steveAllen0112
 * 
 * ###### INPUT #######
 * 
 * "JSON.sortedAndCategorizedStartsAndEnds" expects either the string "UseBuiltInTestData" OR
 * a JSON Object, wherein the Keys are specific times, and the value attached to each key is a String,
 * either "E" or "S", which stand for "End" or "Start".
 * 
 * ###### OUTPUT ######
 * 
 * A JSON Array wherein each item is an Object with a Start and End,
 * Representing a full and maximized contiguous block of time.
 * 
 * Two things MUST be true of this collection in order for it to work as expected.
 * 
 * 1) It MUST be ordered.  Specifically it MUST be sorted by Time, from earliest to latest, regardless of type.
 *     Technically, JSON Objects are not Ordered, but this one does care, because it is fundamental to the concept.
 * 
 * 2) When two times are identical (same key) -- If they are of differing type, the value supplied MUST be "S".
 *     (That is, "S" is preferred over "E".)  This is likewise fundamental to the concept.
 *
 * ##### EXPLANATION ######
 * This algorithm works by identifying the maximized block borders by the following concept, then using
 * the border identification to locate the times associated with them.
 *
 * When sorted and Start-preferred, a true border is where an End is followed by a Start.
 * This is because for any given S, if it is followed by another S, then there is an overlap,
 * and the earlier S should be preferred, as providing a larger contiguous block.
 *
 * Likewise, if any given E, is followed by a further E, then the later E should be preferred
 * for the same reason.
 *   
 * But SE is not a border either (necessarily) because it is simply a time block.  The only real border
 * is when a S is not preceeded by an S, and an E is not followed by an E.  (per the above)
 * In other words, "ES".  Not "SE", nor "SS" because the predecessor to the first "S" could be another "S".
 * And also because the "E" might also be followed by another "E".  But with "ES", the "S" cannot possibly
 * be preceeded by another "S", because it is known to be preceeded by an "E", and likewise the "E" cannot
 * possibly be followed by another "E", because it is known to be followed by an "S".  So this is a true border.
 *  
 * To make things consistent, we add an "E" before and an "S" after the data provided, reflecting the fact that
 * (because we are at the extreme ends), the first "S" is known to not be proceeded by another "S", and the
 * last "E" is known not to be followed by another "E".  Adding the two to their respective opposite ends ensures
 * that these ends are properly understood as borders also.
 * 
 * After this, we count the borders.  However, this would leave us with one too many, as follows.
 * For any X number of slots, it has both a left and a right.  However, these are butted up one against the other,
 * and the right of one forms the left of the next, and there is one border.
 * Counting from the left, we can identify the same number of "lefts" as there are blocks.  (thus the preference for "S" over "E")
 * Each "left" is also a "right", but that leaves us with a final "right" that is not also a "left".
 * So to get the actual number of Blocks, we need to take the number of borders ("lefts" + "right") and subtract the last "right".  (i.e. minus 1)
 *
 * Next, we recognize that since we are using a single letter to represent the entry ("E" or "S"), there is naturally a
 * one-to-one correspondence between the letter's position in the String of letters and it's Key (i.e. time's) position in
 * the List of Times.
 * So to find the PositionValue of the Start Time at any given border, we just need to find the Position of the border
 * itself (i.e. the "left" border) in the String.  And to find the PositionValue of the End Time at any given border, we just need to find the Position
 * of the _next_ border (i.e. the "right" border) in the String.  However, that is technically the Start of the next block
 * (because of our preference for "S" over "E"), so we need to back up one position to get the End of the current block.  (i.e. minus 1)
 *
 * ##### SPEED #####
 * This algorithm should be incredibly fast, because it uses a PatternCount() on a String to identify the borders,
 * and it IGNORES everything but what's at the borders, so it only loops {# of slots} times.
 */

Let ([b=""
;	times = Case ( JSON.sortedAndCategorizedStartsAndEnds = "UseBuiltInTestData" ; JSONSetElement ( "{}"
		;[ GetAsNumber ( Time ( 8 ; 0 ; 0 ) ) ; "S" ; JSONString ]
		;[ GetAsNumber ( Time ( 8 ; 15 ; 0 ) ) ; "S" ; JSONString ]
		;[ GetAsNumber ( Time ( 9 ; 15 ; 0 ) ) ; "E" ; JSONString ]
		;[ GetAsNumber ( Time ( 9 ; 30 ; 0 ) ) ; "E" ; JSONString ]
		;[ GetAsNumber ( Time ( 10 ; 0 ; 0 ) ) ; "S" ; JSONString ]
		;[ GetAsNumber ( Time ( 10 ; 30 ; 0 ) ) ; "S" ; JSONString ]
		;[ GetAsNumber ( Time ( 11 ; 0 ; 0 ) ) ; "S" ; JSONString ]
		;[ GetAsNumber ( Time ( 11 ; 15 ; 0 ) ) ; "E" ; JSONString ]
		;[ GetAsNumber ( Time ( 11 ; 30 ; 0 ) ) ; "E" ; JSONString ]
		;[ GetAsNumber ( Time ( 11 ; 45 ; 0 ) ) ; "E" ; JSONString ]
		;[ GetAsNumber ( Time ( 12 ; 0 ; 0 ) ) ; "E" ; JSONString ]
		) ; JSON.sortedAndCategorizedStartsAndEnds )

;	timesList = JSONListKeys ( times ; "" )
;	typesList = JSONListValues ( times ; "" )
;	typesString = "E" &amp; Substitute ( typesList ; "¶" ; "" ) &amp; "S"

;	slotQty = PatternCount ( typesString ; "ES" ) - 1

;	output = While ([b=""
		;	slot = 1
		;	output = "[]"
		];
			slot &lt;= slotQty
		;[b=""
		;	startPos = Position ( typesString ; "ES" ; 1 ; slot )
		;	endPos = Position ( typesString ; "ES" ; 1 ; slot + 1 ) - 1

		;	start = GetAsTime ( GetAsNumber ( GetValue ( timesList ; startPos ) ) )
		;	end = GetAsTime ( GetAsNumber ( GetValue ( timesList ; endPos ) ) )

		;	output = JSONSetElement ( output ; "[" &amp; slot - 1 &amp; "]" ; JSONSetElement ( "{}"
			;[ "start" ; start ; JSONString ]
			;[ "end" ; end ; JSONString ]
			) ; JSONObject )

		;	slot = slot + 1
		];
			output
		)
];
output
)</Calculation></CustomFunction></fmxmlsnippet></Clipboard><Picture></Picture></FMClipboard>