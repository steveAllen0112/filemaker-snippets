<?xml version="1.0" encoding="UTF-8"?><FMClipboard><Version><![CDATA[41011080]]></Version><Comment><![CDATA[v18+ only]]></Comment><SourceWindowName></SourceWindowName><Class>XMFN</Class><ClipVersion>1</ClipVersion><ClipTimeStamp>3637300875</ClipTimeStamp><ClipAuthor><![CDATA[gsbcs]]></ClipAuthor><clipboardAsText><![CDATA[JSON.array.appendKey( array )
JSON.array.count( array )
JSON.array.toList( array )
JSON.array.fromList( lst;type )
JSON.array.push( arr;val;type )
JSON.defaultTo( jsonResult;default )
JSON.record.getData( Definition )
JSON.record.getFields( context )
JSON.setVariables( json )]]></clipboardAsText><Clipboard><fmxmlsnippet type="FMObjectList"><CustomFunction id="14" functionArity="1" visible="True" parameters="array" name="JSON.array.appendKey"><Calculation>Let ([b=""
;	indices = JSONListKeys ( array ; "" )
;	next = Case ( Left ( indices ; 1 ) = "?" ; 0 ; GetAsNumber ( GetValue ( indices ; ValueCount ( indices ) ) ) + 1 )
];
next
)</Calculation></CustomFunction><CustomFunction id="58" functionArity="1" visible="True" parameters="array" name="JSON.array.count"><Calculation>Case ( IsEmpty ( array ) ; 0 ; Let ([b=""

;	keys	= JSONListKeys ( array ; "" )
;	cnt	= Case ( Left ( keys ; 1 ) = "?" ; 0 ; ValueCount ( keys ) )
	
];
cnt
))</Calculation></CustomFunction><CustomFunction id="61" functionArity="1" visible="True" parameters="array" name="JSON.array.toList"><Calculation>Case ( array = "[]" or Left ( array ; 1 ) = "?" ; "" ; JSONListValues ( array ; "" ) )</Calculation></CustomFunction><CustomFunction id="17" functionArity="2" visible="True" parameters="lst;type" name="JSON.array.fromList"><Calculation>Let ([b=""

;	$_array	= "[]"

;	template	= ";	$_array = JSON.array.push ( $_array ; " &amp; Case ( type = JSONNumber ; "{{value}}" ; Quote ( "{{value}}" ) ) &amp; " ; " &amp; type &amp; " )"
;	values = lst
;	pushes	= List.fillTemplate ( template ; lst )
;	str	= List (""
			; "Let ([b=\"\""
			; ";	$_array = \"[]\""
			;	pushes
			; "];"
			; "	$_array"
			; ")"
			)

;	res	= Evaluate ( str )
;	output	= $_array
;	$_array	= ""

];
output
)</Calculation></CustomFunction><CustomFunction id="16" functionArity="3" visible="True" parameters="arr;val;type" name="JSON.array.push"><Calculation>Let ([b=""
/*
;	arr	= "[]"
;	val	= "test"
;	type 	= JSONString
*/

;	keys	= JSONListKeys ( arr ; "" )
;	len	= ValueCount ( keys )

;	thisKey	= GetValue ( keys ; len )
;	nextKey	= Case ( IsEmpty ( thisKey ) ; 0 ; thisKey + 1 )

;	return	= JSONSetElement ( arr ; nextKey ; val ; type )

];
	return
)</Calculation></CustomFunction><CustomFunction id="20" functionArity="2" visible="True" parameters="jsonResult;default" name="JSON.defaultTo"><Calculation>Case ( Left ( jsonResult ; 1 ) = "?" ; default ; jsonResult )</Calculation></CustomFunction><CustomFunction id="12" functionArity="1" visible="True" parameters="Definition" name="JSON.record.getData"><Calculation>/*
 * @author Steve Allen &lt;steven.allen@rcconsulting.com&gt;
 *    @gitHub steveAllen0112
 *
 * @purpose To contextually and consistently produce record data in JSON format
 *     Uses the Schema Definition provided to it (See `JSON.record.getFields()` as a way to produce that.)
 *     This prevents having to hard-code a CF for each table, and allows flexibility to be as consistent or not as needed at runtime.
 * 
 * @param *required Definition (object)
 *    @property *required _table (string) The name of the Table Occurrence to grab the data from.  Must be reachable in the context.
 *        Only required at the first level of the call, but must be present there or the CF will not work,
 *           because it's used to fully qualify the field definitions passed in the rest of the Schema Definition
 *    @properties *required {Schema-Definition} See the @return value on the `JSON.record.getFields()` function.
 *
 * @returns {record-data} (object)
 *     Exact structure will vary according to the Definition provided, but will match that definition's structure.
 */

Let ([b=""
;	debug = False

;	properties		= JSON.defaultTo ( JSONListKeys ( Definition ; "" ) ; "" )

;	hasTableDefinition	= ValueCount ( FilterValues ( properties ; "_table" ) ) &gt;= 1
;	isFieldDefinition		= ValueCount ( FilterValues ( properties ; List ( "field" ; "type" ; "reps" ) ) ) &gt;= 3 /* these all have to be there for it to be considered a Field Definition. */

;	Definition		= Case ( hasTableDefinition
					;	Let ([b=""
						;	$_log = ""
						;	$_output = ""
						;	$_iterator = ""
						;	$_context = JSONSetElement ( "{}"
								;[ "table" ; JSON.defaultTo ( JSONGetElement ( Definition ; "_table" ) ; "" ) ; JSONString ]
								)
						];
							JSONDeleteElement ( Definition ; "_table" )
						)
					; Definition
					)

;	$_iterator		= Case ( IsEmpty ( $_iterator )
					;	JSONSetElement ( "{}"
							;[ "iteration" ; 1 ; JSONNumber ]
							;[ "stopAt" ; Case (0;0
								;	isFieldDefinition
								;		JSON.defaultTo ( JSONGetElement ( Definition ; "reps" ) ; "" )
								;	ValueCount ( properties ) - hasTableDefinition
								) ; JSONNumber ]
							)
					; $_iterator
					)

;	Iterator			= $_iterator


;	$_log			= Case ( debug ; List ( $_log ; "---------" ; JSONSetElement ( "{}"
					;[ "properties" ; properties ; JSONString ]
					;[ "isFieldDefinition" ; isFieldDefinition ; JSONBoolean ]
					;[ "Iterator" ; Iterator ; JSONObject ]
					;[ "output" ; $_output ; JSONObject ]
					)))


;	iteration			= JSON.defaultTo ( JSONGetElement ( Iterator ; "iteration" ) ; "" )

;	dig			= Case (0;0
				;	isFieldDefinition
				;		Let ([b=""
						;	table			= JSON.defaultTo ( JSONGetElement ( $_context ; "table" ) ; "" )
						;	field.name		= JSON.defaultTo ( JSONGetElement ( Definition ; "field" ); "" )
						;	field.type		= JSON.defaultTo ( JSONGetElement ( Definition ; "type" ); "" )
						;	field.reps		= JSON.defaultTo ( JSONGetElement ( Definition ; "reps" ); "" )
						;	field.rep			= iteration
						;	field.name.fullyQualified	= Substitute ( "{{table}}::{{field}}[{{rep}}]"
											;[ "{{table}}" ; Table ]
											;[ "{{field}}" ; field.name ]
											;[ "{{rep}}" ; field.rep ]
											)
						;	field.value		= Evaluate ( field.name.fullyQualified )

						;	field.jsonKey		= field.name &amp; Case ( field.reps &gt; 1 ; "." &amp; field.rep )

						;	$_log			= Case ( debug ; List ( $_log ; "      ----- " ; JSONSetElement ( "{}"
											;[ "field.name" ; field.name ; JSONString ]
											;[ "field.type" ; field.type ; JSONNumber ]
											;[ "field.reps" ; field.reps ; JSONNumber ]
											;[ "field.rep" ; field.rep ; JSONNumber ]
											;[ "field.fullyQualifiedName" ; field.name.fullyQualified ; JSONString ]
											;[ "field.jsonKey" ; field.jsonKey ; JSONString ]
											;[ "field.value" ; field.value ; JSONString ]
											)))

						;	$_output			= JSONSetElement ( $_output ; field.jsonKey ; field.value ; field.type )
						];"")
				;	Let ([b=""
					;	thisProp		= GetValue ( properties ; iteration )
					;	thisPropVal	= JSONGetElement ( Definition ; thisProp )

					;	$_log		= Case ( debug ; List ( $_log ; "  -- " ; JSONSetElement ( "{}"
									;[ "thisProp.name" ; thisProp ; JSONString ]
									;[ "thisProp.value" ; thisPropVal ; Case ( Left ( thisPropVal ; 1 ) = "{" ; JSONObject ; JSONString ) ]
									)))

					;	$_iterator	= ""
					;	dig		= JSON.record.getData ( thisPropVal )
					;	$_iterator	= Iterator
					]; "" )
				)

	/* Now iterate as necessary */
;	stopAt			= JSON.defaultTo ( JSONGetElement ( Iterator ; "stopAt" ) ; 0 )
;	iterate			= Case ( iteration &lt;  stopAt
					; Let ( $_iterator = JSONSetElement ( $_iterator ; "iteration" ; iteration + 1 ; JSONNumber )
						; JSON.record.getData ( Definition )
						)
					)
];
Case ( debug ; $_log ; $_output )
)</Calculation></CustomFunction><CustomFunction id="11" functionArity="1" visible="True" parameters="context" name="JSON.record.getFields"><Calculation>/*
 * @author Steve Allen &lt;steven.allen@rcconsulting.com&gt;
 * @purpose To provide a flexible method of consistently defining a data structure for a table such that other functions (e.g. `JSON.record.getData()`) can follow it and read data out of the record.
 *
 * @param context (object)
 *   @property *required _table (string) The name of the TO that will be used to get the field data.
 *   @property *optional config (object)
 *      @property *optional include (array) If this array is present, it will limit the fields included to only those specified therein.
 *        @member *optional field (string) The name (field only, not the fully qualified name) of the field you wish to include.
 *      @property *optional exclue (array) If this array is present, it will actively prevent inclusion of those fields specified therein.
 *        @member *optional field (string) The name (field only, not the fully qualified name) of the field you wish to exclude.
 *
 * @returns (object)
 *    @property {hierarchy-parent | Field-Definition} (obj)
 *        hiearchy-parent If field names have dots in them, they will be treated as a JSON path.  e.g. name.first.  So the hierarchy parent would have the children within that hiearchy as properties under it
 *        Field-Definition At the lowest level of the naming hierarchy, the actual definition
 *          @property field (str) The full, unqualified name of the field.
 *          @property type (number) The numeric representation of the JSON type as specified by FileMaker's built in constants.
 *             (JSONNumber | JSONString )
 *          @property reps (number) The number of repetitions defined for the field.
 */

Let ([b=""

;	context.table	= JSON.defaultTo ( JSONGetElement ( context ; "table" ) ; "" )
;	config.include	= JSON.defaultTo ( JSONGetElement ( context ; "config.include" ) ; "" )
;	config.exclude	= JSON.defaultTo ( JSONGetElement ( context ; "config.exclude" ) ; "" )

;	$record = "{}"

;	config.include	= Case ( not IsEmpty ( config.include ) ; Substitute ( config.include
					;[ "\"" ; "'" ]
					;[ "[" ; "(" ]
					;[ "]" ; ")" ]
					)
				)
;	config.exclude	= Case ( not IsEmpty ( config.exclude ) ; Substitute ( config.exclude
					;[ "\"" ; "'" ]
					;[ "[" ; "(" ]
					;[ "]" ; ")" ]
					)
				)

;	flds = Substitute ( List ( ""
		; "'	$record	= JSONSetElement ( $record'"
		; "'			;[ \"' + FieldName + '.field\" ; \"' + FieldName + '\" ; JSONString ]'"
		; "'			;[ \"' + FieldName + '.type\" ; ' +
						CASE
							WHEN FieldType LIKE 'decimal%' THEN 'JSONNumber'
							ELSE 'JSONString'
						END
				+ ' ; JSONNumber ]'"
		; "'			;[ \"' + FieldName + '.reps\" ; ' + CAST ( FieldReps AS varchar ) + ' ; JSONNumber ]'"
		; "'			)'"
		)
		;[ "¶" ; ",¶" ]
		)

;	sqlStr = "
SELECT
	" &amp; flds &amp; "

FROM FileMaker_Fields

WHERE
		TableName=?
	AND	FieldClass='Normal'
"
&amp; Case ( not IsEmpty ( config.include ) ; " AND FieldName IN " &amp; config.include )
&amp; Case ( not IsEmpty ( config.exclude ) ; " AND FieldName NOT IN " &amp; config.exclude ) 

;	sqlRes = ExecuteSQL ( sqlStr ; "¶" ; ";" ; context.table )
;	errChk = Case ( sqlRes = "?" ; "" ; "Let ([ b=\"\";" &amp; sqlRes &amp; "];$record)" )

;	json = Case ( IsValidExpression ( errChk ) ; Evaluate ( errChk ) ; "" )

];
json
)</Calculation></CustomFunction><CustomFunction id="23" functionArity="1" visible="True" parameters="json" name="JSON.setVariables"><Calculation>Case ( not IsValidExpression ( While (i=0;0;i=0;0) ) ; "?" ;

While ([b=""
/* For Testing
;	json = JSONSetElement ( "{}"
		;[ "test[0].hello" ; "world" ; JSONString ]
		;[ "test[0].ping" ; "pong" ; JSONString ]
		;[ "test[1].number" ; 1 ; JSONNumber ]
		;[ "test[1].date" ; GetAsNumber ( Get ( CurrentDate ) ) ; JSONNumber ]
		)
*/
;	path = "[]"
;	variables = ""
;	currentJson = json
]; ValueCount ( JSONListKeys ( json ; "" ) )
;[b=""
;	jsonPath = Substitute ( JSONListValues ( path ; "" ) ; "¶" ; "." )

;	currentJson = JSONGetElement ( json ; jsonPath )

;	currentJson.isValue	= Left ( JSONFormatElements ( currentJson ) ; 1 ) = "?"
;	currentJson.isArray	= (not currentJson.isValue) and Left ( currentJson ; 1 ) = "["
;	currentJson.isObject	= (not currentJson.isValue) and Left ( currentJson ; 1 ) = "{"
;	currentJson.isDone	= (currentJson.isArray or currentJson.isObject) and Length ( currentJson ) = 2

;	variables = Case (0;0
			;	currentJson.isValue
			;		Let ([b=""
					;	variable = "$" &amp; Substitute ( jsonPath ; [ "[" ; "" ] ; [ "]" ; "" ] )
					;	evalStr	= "Let(" &amp; variable &amp; "=" &amp; Quote ( currentJson ) &amp; ";\"\")"
					;	set = Evaluate ( evalStr )
					];
						List ( variables ; variable )
					)
			;	variables
			)

;	path	= Case (0;0
			;	currentJson.isValue or currentJson.isDone
			;		Let ([b=""
					;	pathkeys = JSONListKeys ( path ; "" )
					;	latestPathKey = GetValue ( pathkeys ; ValueCount ( pathkeys ) )
					];
						JSONDeleteElement ( path ; latestPathKey )
					)
			;	currentJson.isObject or currentJson.isArray
			;		Let ([b=""
					;	pathkeys = JSONListKeys ( path ; "" )
					;	latestPathKey = GetValue ( pathkeys ; ValueCount ( pathkeys ) )
					;	nextKey = GetValue ( JSONListKeys ( currentJson ; "" ) ; 1 )
					;	nextKey = Case ( currentJson.isArray ; "[" &amp; nextKey &amp; "]" ; nextKey )
					];
						JSONSetElement ( path ; "[" &amp; latestPathKey + 1 &amp; "]" ; nextKey ; JSONString )
					)
			;	path
			)
;	json	= Case (0;0
			;	currentJson.isValue or currentJson.isDone
			;		JSONDeleteElement ( json ; jsonPath )
			;	json
			)
];
variables
) )</Calculation></CustomFunction></fmxmlsnippet></Clipboard><Picture></Picture></FMClipboard>